<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Studio</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
<div class="container">

    <a href="gallery.html" class="btn gallery-nav-btn gallery-nav"><i class="fas fa-images"></i> GALLERY</a>

    <h1>AI STUDIO <i class="fas fa-paint-brush"></i></h1>

    <div class="card step-card">
        <h2>01. MODE</h2>
        <div class="mode-selector">
            <button class="btn mode-btn active" data-mode="image" title="PC 파일 변환"><i class="fas fa-desktop"></i></button>
            <button class="btn mode-btn" data-mode="text" title="텍스트 생성"><i class="fas fa-keyboard"></i></button>
            <button class="btn mode-btn" data-mode="qr" title="모바일 사진 전송"><i class="fas fa-qrcode"></i></button>
        </div>
    </div>

    <div class="card step-card">
        <h2>02. INPUT</h2>

        <section id="imageMode" class="mode-content">
            <input type="file" accept="image/*" name="pcImage" id="fileUploader" style="display: none;">
            <button id="uploadButton" class="btn primary-btn full-width"><i class="fas fa-upload"></i> PC 파일 선택</button>
            <img id="originalImage" alt="업로드된 원본 이미지" class="preview-img" style="display: none;">
            <p id="fileStatus" class="status-text"></p>
        </section>

        <section id="textMode" class="mode-content" style="display: none;">
            <textarea id="textPromptInput" placeholder="생성할 이미지를 입력하세요..." rows="3" class="input-full"></textarea>
            <p class="safety-note">⚠️ 부적절한 내용은 거부됩니다.</p>
        </section>

        <section id="qrMode" class="mode-content" style="display: none;">
            <button id="qrUploadStartButton" class="btn primary-btn full-width"><i class="fas fa-mobile-alt"></i> QR 생성</button>

            <div id="qrBridgeArea" class="qr-bridge-area" style="display: none; text-align: center;">
                <h4>SCAN TO UPLOAD</h4>
                <div id="qrcode" class="qr-box"></div>
                <p id="qrBridgeStatus" class="status-text note"></p>
                <button id="cancelQrButton" class="btn secondary-btn small-btn">CANCEL</button>
            </div>

            <img id="qrOriginalImage" alt="QR로 업로드된 이미지" class="preview-img" style="display: none;">
            <p id="qrFileStatus" class="status-text"></p>
        </section>

        <div id="commonAISettings" class="common-settings">
            <h4>03. SETTINGS</h4>
            <textarea id="stylePromptInput" placeholder="스타일 입력 (예: cinematic, low-poly)" rows="2" class="input-full"></textarea>
            <select id="styleSelect" class="input-full">
                <option value="default">STYLE (Optional)</option>
                <option value="cartoon">Cartoon</option>
                <option value="oilpainting">Oil Painting</option>
                <option value="watercolor">Watercolor</option>
                <option value="pixelart">Pixel Art</option>
                <option value="photorealistic">Photorealistic</option>
                <option value="cyberpunk">Cyberpunk</option>
            </select>
        </div>
    </div>

    <div class="card action-area">
        <button id="aiConvertButton" class="btn action-btn full-width">✨ GENERATE</button>
    </div>
</div>

<div id="fullScreenLoading" class="full-screen-loading" style="display: none;">
    <img src="brush_loading_bw.gif" alt="Processing..." class="loading-gif-full">
    <p class="loading-text-full">PROCESSING...</p>
</div>

<script>
    let currentMode = 'image';
    let pcUploadedFile = null;
    let qrUploadedFileName = null;
    let currentSessionId = null;
    let pollingInterval = null;

    const fileUploader = document.getElementById('fileUploader');
    const uploadButton = document.getElementById('uploadButton');
    const originalImage = document.getElementById('originalImage');
    const fileStatus = document.getElementById('fileStatus');
    const qrUploadStartButton = document.getElementById('qrUploadStartButton');
    const qrBridgeArea = document.getElementById('qrBridgeArea');
    const qrcodeDiv = document.getElementById('qrcode');
    const qrBridgeStatus = document.getElementById('qrBridgeStatus');
    const cancelQrButton = document.getElementById('cancelQrButton');
    const qrOriginalImage = document.getElementById('qrOriginalImage');
    const qrFileStatus = document.getElementById('qrFileStatus');

    const fullScreenLoading = document.getElementById('fullScreenLoading');
    const loadingGif = document.querySelector('.loading-gif-full');
    const loadingText = document.querySelector('.loading-text-full');

    // --- GIF 타이밍 상수는 이제 사용하지 않음 (버벅거림 방지) ---
    // 버벅거림 제거를 위해 setTimeout 대신 CSS transition 완료를 기다림

    // --- 모드 전환, 업로드, QR 로직 (유지) ---
    document.querySelectorAll('.mode-btn').forEach(button => {
        button.addEventListener('click', () => {
            currentMode = button.dataset.mode;
            document.querySelectorAll('.mode-content').forEach(content => content.style.display = 'none');
            document.getElementById(currentMode + 'Mode').style.display = 'block';
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            button.classList.add('active');

            if (pollingInterval) clearInterval(pollingInterval);
            qrBridgeArea.style.display = 'none';
            qrUploadStartButton.style.display = 'inline-block';
        });
    });

    uploadButton.addEventListener('click', () => fileUploader.click());
    fileUploader.addEventListener('change', (event) => { /* ... (로직 유지) ... */
        pcUploadedFile = event.target.files[0];
        qrUploadedFileName = null;

        const reader = new FileReader();
        reader.onload = (e) => {
            originalImage.src = e.target.result;
            originalImage.style.display = 'block';
            fileStatus.textContent = `File: ${pcUploadedFile.name}`;
            qrOriginalImage.style.display = 'none';
        };
        reader.readAsDataURL(pcUploadedFile);
    });

    qrUploadStartButton.addEventListener('click', startQrUploadSession);
    cancelQrButton.addEventListener('click', cancelQrUploadSession);

    async function startQrUploadSession() { /* ... (로직 유지) ... */
        const response = await fetch('/api/start-upload-session');
        const data = await response.json();
        currentSessionId = data.sessionId;
        const baseUrl = data.origin;

        if (!currentSessionId) return alert('Session start failed.');

        qrBridgeArea.style.display = 'block';
        qrUploadStartButton.style.display = 'none';

        const mobileUploadUrl = `${baseUrl}/upload.html?id=${currentSessionId}`;

        qrcodeDiv.innerHTML = '';
        new QRCode(qrcodeDiv, { text: mobileUploadUrl, width: 150, height: 150 });
        qrBridgeStatus.textContent = "Scan the QR code to upload.";

        pollingInterval = setInterval(checkUploadStatus, 1000);
    }

    async function checkUploadStatus() { /* ... (로직 유지) ... */
        if (!currentSessionId) return;
        const response = await fetch(`/api/check-upload-status/${currentSessionId}`);
        const data = await response.json();

        if (data.status === 'uploaded') {
            clearInterval(pollingInterval);
            currentSessionId = null;

            qrUploadedFileName = data.fileInfo.fileName;
            pcUploadedFile = null;

            qrOriginalImage.src = `/images/uploads/${qrUploadedFileName}`;
            qrOriginalImage.style.display = 'block';
            qrFileStatus.textContent = `Upload complete: ${data.fileInfo.originalName}`;

            qrBridgeArea.style.display = 'none';
            qrUploadStartButton.style.display = 'inline-block';
            alert('Mobile upload complete. Start generation.');
        }
    }

    function cancelQrUploadSession() { /* ... (로직 유지) ... */
        if (pollingInterval) clearInterval(pollingInterval);
        currentSessionId = null;
        qrBridgeArea.style.display = 'none';
        qrUploadStartButton.style.display = 'inline-block';
    }

    // --- AI 변환 버튼 클릭 시 (핵심 로직: 버벅거림 제거 및 부드러운 전환) ---
    document.getElementById('aiConvertButton').addEventListener('click', async () => {
        // ... (안전 필터링 로직 유지) ...
        const DANGER_KEYWORDS = ['sex', 'nude', 'violence', 'gun', 'weapon', 'gore', 'child abuse', 'explicit', 'hate speech', 'bloody'];
        let prompt = document.getElementById('textPromptInput').value;
        const style = document.getElementById('styleSelect').value;
        const stylePrompt = document.getElementById('stylePromptInput').value;
        const fullPrompt = prompt + (stylePrompt ? ', ' + stylePrompt : '');
        const lowerCasePrompt = fullPrompt.toLowerCase();
        let safetyViolation = false;
        for (const keyword of DANGER_KEYWORDS) {
            if (lowerCasePrompt.includes(keyword)) {
                safetyViolation = true;
                break;
            }
        }
        if (safetyViolation) {
            return alert('⚠️ 콘텐츠 정책 위반 가능성이 있는 키워드가 감지되었습니다. 내용을 수정해주세요.');
        }

        const formData = new FormData();
        formData.append('prompt', fullPrompt);
        formData.append('style', style);
        formData.append('mode', currentMode);

        if (currentMode === 'image' && pcUploadedFile) {
            formData.append('pcImage', pcUploadedFile);
        } else if (currentMode === 'qr' && qrUploadedFileName) {
            formData.append('qrUploadedFileName', qrUploadedFileName);
        } else if (currentMode === 'text' && prompt) {
            // Text to Image: 파일 필요 없음
        } else {
            return alert(`[${currentMode} Mode] Missing input.`);
        }

        // ⭐️ [STAGE 1: 검은색으로 덮기 (부드러운 시작)]
        fullScreenLoading.style.display = 'flex';
        fullScreenLoading.classList.add('active'); // 0.3s 동안 opacity 0 -> 1로 전환

        // ⭐️ [STAGE 2: GIF 표시 및 AI 요청 병행]
        // 검은색 화면이 완전히 덮일 때까지 짧게 기다린 후 GIF를 표시
        setTimeout(() => {
            loadingGif.style.opacity = 1; // GIF를 부드럽게 표시
        }, 350); // 0.3s transition + 50ms 안전 대기

        try {
            // 1. AI 응답을 기다리는 Promise
            const aiData = await fetch('/api/ai-process', { method: 'POST', body: formData })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(errorData => {
                            throw new Error(errorData.error || 'Generation failed (Server Error)');
                        });
                    }
                    return response.json();
                });

            // 2. AI 응답 도착 후, 부드러운 전환 시작
            if (aiData.filename) {

                // a) 배경을 흰색으로 변경하고 텍스트 색상 변경 (CSS transition이 적용됨)
                fullScreenLoading.style.backgroundColor = 'white';
                loadingText.style.color = 'black';
                loadingGif.style.filter = 'none'; // GIF의 색상을 흰색 배경에 맞춰 변경 (선택 사항)

                // b) 흰색 배경 전환을 위한 시간 (0.1s transition + 50ms)
                await new Promise(resolve => setTimeout(resolve, 150));

                // c) download.html로 즉시 리디렉션 (버벅거림 제거)
                let redirectUrl = `download.html?file=${aiData.filename}&mode=${aiData.mode}`;
                if (aiData.visionDescription) {
                    redirectUrl += `&desc=${encodeURIComponent(aiData.visionDescription)}`;
                }
                window.location.href = redirectUrl;
            } else {
                alert('Result URL not received.');
            }
        } catch(e) {
            alert(`Error: ${e.message || 'Network error or processing error.'}`);
            console.error("Fetch/System Error:", e);
            // 에러 발생 시 부드럽게 복구
            fullScreenLoading.classList.remove('active');
        } finally {
            // 최종 상태 초기화 (active 클래스가 제거되면 CSS transition으로 다시 사라짐)
            loadingGif.style.opacity = 0;
            fullScreenLoading.style.backgroundColor = 'rgba(0, 0, 0, 0.95)';
            loadingText.style.color = 'white';
            setTimeout(() => {
                fullScreenLoading.style.display = 'none';
            }, 400); // GIF 사라지는 시간만큼 기다림
        }
    });

    document.querySelector('.mode-btn[data-mode="image"]').click();
</script>
</body>
</html>